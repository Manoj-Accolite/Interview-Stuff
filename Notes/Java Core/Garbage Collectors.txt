https://www.youtube.com/watch?v=UnaNQgzw4zY

Before Java we had to allocate and de-allocate memory
	- malloc() / realloc() / calloc()
	- free()
	- new and destructors

But java provides automatic memory management through a program called "Garbage Collector" -> Remove objects that are not used anymore
live object = reachable (referenced by someone else)
dead object = unreachable (not referenced from anywhere)

	-- Objects are allocated (eg: new) in the heap of java memory.
	-- Static members, class definitions (Metadata) etc are stored in "method area" (Permgen/Metaspace in java 8)
	-- Garbage Collection is carried out by a daemon thread called "Garbage Collector". we cannot force gc to happen (System.gc())
	-- When new allocations can not happen due to full heap, you end up with java.lang.OutOfMemoryError heap space 
	
garbage Collection involves 3 steps
1) Mark			 - Starts from root node of the appln(main), walks the object graph, marks objects thar are reachable as live
2) Delete/Sweep	 - Delete unreachable objects
3) Compacting	 - Compact the memory by moving around the objects and making the allocation contiguous than fragmented

Heap is divided into 2 generational collectors
1) Young generation -> comprises of Eden space (new objs are created), Survivor space from (when Eden space is full, small garbage collection kicks in and cleans up unreachable objs in Eden space and moves reachable objs to Survivor Space, which means the survived objs are moved here and new objcts are again stored in Eden), Survivor to
2) Old (Tenured) generation -> Objs that are survived for a long time (Eg: Cache which is created in appl, which survives entire appln)(If it survives some iterations of garbage collection and if it survives all these iterations

Minor and Major garbage collection(Garbage Collector)
Minor -> These run on Eden and Survivor Spaces
To avoid compacting, there are multiple Survivor Spaces
In order for the objects to be promoted to Old generation space, the objcts need to survive cycles of garbage collection, I mean they need to survive a "MaxTenuringThreshold"
If Old generation gets full or if almost full, the major garbage collector kicks in and goes over all generations and performs Mark, Sweep, Compacting; this will be a huge process and takes time coz it runs through entire heap

Performance:
1) Responsiveness / Latency :- How quickly an appln response with a requested piece of data. Eg) how fast a website returns a page, How fast a db returns a query.
For applns that focus on responsiveness, large pause times are not acceptable and they cannot afford.The focus is on responding in shorts of time

2) Throughput :- Focusses on maximizing the amount of work by an appln in a specific period of time. Eg) No. of transactions completed in given time, No of db queries that can be completed in an hour.
High pause times are acceptable for applns that focus on throughput  

Garbage collectors Types:
1) Serial Garbage collector:
	When the appln runs, and it pauses then Serial Garbage Collector runs and after that appln continues
	Basic Garbage Collector that runs in a single thread, can be used for basic applns
2) Concurrent Garbage Collector:
	It runs along with the appln. I mean parallely
	It does not wait for the old generation to be full. Stops the world only during Mark / re-Mark
3) Parallel Garbage Collector:
	Uses multiple cores of CPU for garbage collection
	Multiple threads doing Mark / Sweep.
	Does not kick in until heap is full / near full. "Stops the world" when it runs
	Great for Batch applns

When to use Concurrent / Parallel ??
- Use Concurrent Collector (CMS - Concurrent Mark Sweep) when,
	There is more memory
	There is high no of CPU's
	Appln demands short pauses (latency)
- Use Parallel Concurrent when,
	There is less memory
	There is lesser no od CPU's
	Appln demands high throughput and can withstand pauses

CMS is used for Web applns and in finance applns

In Java 1.7, G1 garbage collector (G1 => Garbage - first)
	- It straddles (gets on) the young generation boundary as it divides heap in to different regions and during a Garbage Collection it can collect a sub-set of regions. It dynamically selects a set of region to act as young generation in next GC cycle. "Regions with most garbage(unreachable) will be collected "first" "
	-- More predictable (tunable) GC pauses  (we could mention how much time we want GC to pause)
	-- Low pauses with fragmentation
	-- Parallelism and Concurrency together
	-- Better heap utilization
	since it works on short pieces of memory regions, its going to be fast
	The whole heap is divided into small regions (say a grid). All the Edin , Survivor and Old tenure space,everything is there but it will sweep the region which has more unreachable memory/object in it
	
How do we use Garbage Collector ??
1) Serial GC -> -XX:+UseSerialGC   => To be used on small heap
2) Parallel GC: -XX:+UseParallelGC => Young generation uses parallel GC, Old generation uses single threaded gc
3) 				-XX:+UseParallelOldGC => Both young and old generations have multithreaded GC
4) 				-XX:+UseParNewGC  => Multi-threaded young generation garbage collector
5) 				-XX:+UseConcMarkSweepGC => Enables concurrent collector. Autoenables ParNewGC by default. Only for Old generation
6) 				-XX:+UseG1GC => Use G1

finalizer : protected void finalize() throws Throwable  ("Do not Use")
There is no guarantee that the object will be garbage collected

// this = new class()  => object is recreated not garbage collected

// Tune the heap
1) -Xmsvalue => min. amout of heap to be allocated to the program
2) -Xmxvalue => max. " " "
3) -XX:NewRatio=ratio (2 means 1/3 Y + 2/3 T)  => here, Y - Young, T - Tenure/Old
4) -XX:NewSize=size
5) -XX:MaxNewSize=size

GC logging: Very useful if GC is the suspect. use grapical tool to analyze the logs
-verbose:gc
-XX:+PrintGCDetails
-Xloggc:gc.log

Also jvisualvm, free tool comes with JDK installation. Which also needs visual gc plugin
jhat -> java heap analyzer tool